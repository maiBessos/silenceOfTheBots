using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using GoE.AppConstants;
using GoE.GameLogic;
using GoE.UI;
using GoE.Policies.Intrusion.SingleTransmissionPerimOnly.Utils;
using static GoE.GameLogic.Utils;
using GoE.Utils.Algorithms;
using GoE.GameLogic.EvolutionaryStrategy;
using GoE.Utils;

namespace GoE.Policies.Intrusion.SingleTransmissionPerimOnly
{
    
    /// <summary>
    /// in this region there are (bad!) attempts for making policies
    /// </summary>
    abstract class ABasicPatrollerHeuristicPolicyProcess
    {
        public static ABasicPatrollerHeuristicPolicyProcess Construct(PreTransmissionMovement prm, 
            IntrusionGameParams gamePrm,
            Grid4Square gameCircumference)
        {
            ABasicPatrollerHeuristicPolicyProcess res = null;

            // FIXME: look at theses ifs. I mean, really. look at them. 
            if (prm is DistanceDistributionPreTransmissionMovement)
                res = new DistanceDistributionProcess();
            if (prm is RotatingPatrollerBoundPreTransmissionMovement)
                res = new RotatingBoundProcess();
            res.init(prm, gamePrm,gameCircumference);
            return res;
        }
        protected abstract void init(PreTransmissionMovement prm, IntrusionGameParams gamePrm, Grid4Square gameCircumference);
        public abstract PatrollersState getNextPatrollersState(PatrollersState currentPatrollersState);
        public abstract PatrollersState getInitialState(); // get a randomized legal initial state for patrollers
        public abstract void setInitialState(PatrollersState initState); // set a state to begin the process from. expects a set previously generated by the same process class
        public abstract PatrollersState getCurrentState(PatrollersState s); // FIXME: dirty solution. allows the process class to attach tag to s
    }
    class DistanceDistributionProcess : ABasicPatrollerHeuristicPolicyProcess
    {
        DistanceDistributionPreTransmissionMovement movementMethod;
        private CyclicList<Tuple<int, int>> lastMovements; // tells how the patrollers moved for the last few rounds
        private Random myRand;
        IntrusionGameParams gamePrm;
        Grid4Square gameCircumference;

        public int targetCWDistance; // used if currentPatrollersState.p1Dir != currentPatrollersState.p2Dir
        PatrollersState currentPatrollersState;

        private enum MovementState : int
        {
            GoingForward = 0,
            ChangingDistance = 1,
        }
        MovementState currentMovementState;

        public DistanceDistributionProcess() { }
        

        protected override void init(PreTransmissionMovement prm, IntrusionGameParams GamePrm, Grid4Square GameCircumference)
        {
            gameCircumference = GameCircumference;
            gamePrm = GamePrm;
            myRand = new ThreadSafeRandom().rand;
            movementMethod = (DistanceDistributionPreTransmissionMovement)prm;
            var initialVals = AlgorithmUtils.getRepeatingValueList((int)Math.Ceiling(1.0 / movementMethod.distancesMgr.maxVelocity),
                                                                   () => { return Tuple.Create(0, 0); });
            lastMovements = new CyclicList<Tuple<int, int>>(initialVals);
            currentMovementState = MovementState.GoingForward;
        }
        public override PatrollersState getInitialState()
        {
            PatrollersState res = new PatrollersState();
            res.p1 = myRand.Next() % gameCircumference.PointCount;
            res.p2 = (res.p1 + movementMethod.distances.CWDistancesPerProb[myRand.Next() % movementMethod.distances.CWDistancesPerProb.Count]) % 
                      gameCircumference.PointCount;
            res.p1Dir = res.p2Dir = chooseForwardDistance();
            return res;
        }
        public override void setInitialState(PatrollersState initState)
        {
            if (initState.p1Dir == initState.p2Dir)
                currentMovementState = MovementState.GoingForward;
            else
                currentMovementState = MovementState.ChangingDistance;
            targetCWDistance = (int)initState.tag;
        }
        public override PatrollersState getNextPatrollersState(PatrollersState CurrentPatrollersState)
        {
            currentPatrollersState = CurrentPatrollersState; 
            // TODO: methods in this class use the member 'currentPatrollersState', but instead
            // of a member, it should be sent as a method argument

            switch (currentMovementState)
            {
                case MovementState.GoingForward:
                    if (myRand.NextDouble() < movementMethod.distancesMgr.c) // optionally change direction
                        startChangingDistance(); // updates locations and directions
                    else if (myRand.NextDouble() < movementMethod.distancesMgr.p)
                        updatePatrollersPositions(0, 0, -currentPatrollersState.p1Dir, -currentPatrollersState.p2Dir); // switch direction
                    else
                        updatePatrollersPositions(1, 1, currentPatrollersState.p1Dir, currentPatrollersState.p2Dir); // proceed normally

                    break;

                case MovementState.ChangingDistance:
                    int exDistance = getExceedingDistance();
                    switch (Math.Abs(exDistance))
                    {
                        case 0:
                            int newDir = chooseForwardDistance(); // FIXME: maybe we shouldn't rotate after finishing changing distance, but if we don't, then when we change distance we need to keep/derive original direction together with patrollers state (since we keep it in a table in optimizer!!!)
                            currentMovementState = MovementState.GoingForward;
                            updatePatrollersPositions(0, 0, newDir, newDir);
                            break;
                        case 1:
                            currentMovementState = MovementState.GoingForward;
                            // we choose one of the patrollers randomly to close the distance
                            // FIXME make sure that overriding p2's direction isn't a problem, from observations/ skewed probability perspective
                            if (0 == (myRand.Next() % 2))
                                updatePatrollersPositions(1, 0, currentPatrollersState.p1Dir, currentPatrollersState.p1Dir);
                            else
                                updatePatrollersPositions(0, 1, currentPatrollersState.p2Dir, currentPatrollersState.p2Dir);
                            //if(exDistance == -currentPatrollersState.p1Dir) // if we give p1 more round in current direction, it will close the exceeding distance
                            //    updatePatrollersPositions(1, 0, currentPatrollersState.p1Dir, currentPatrollersState.p1Dir); // FIXME: make sure that overriding p2's direction isn't a problem, from observations/skewed probability perspective
                            //else // otherwise, we let p2 close the distance, and p1 stands in place
                            //    updatePatrollersPositions(0, 1, currentPatrollersState.p2Dir, currentPatrollersState.p2Dir); // FIXME: make sure that overriding p2's direction isn't a problem

                            break;
                        default: // >=2
                            updatePatrollersPositions(1, 1, currentPatrollersState.p1Dir, currentPatrollersState.p2Dir); break;
                    }

                    break;
            }

            return currentPatrollersState;
        }
        private int chooseForwardDistance()
        {
            return (-1 + 2 * (myRand.Next() % 2)); // 50/50 chance for going CW or CCW
        }
        float p1AvgVel, p2AvgVel;
        /// <summary>
        /// 
        /// </summary>
        /// <param name="p1Moves">
        /// 0 if p1 is standing in place instead of advancing towards p1Dir (e.g. due to rotation), 1 otherwise
        /// </param>
        /// <param name="p2Moves">
        /// similar to p2Stands
        /// </param>
        private void updateAvgVel(int p1Moves, int p2Moves)
        {
            p1AvgVel -= lastMovements.Oldest.Item1 / lastMovements.Data.Count;
            p2AvgVel -= lastMovements.Oldest.Item2 / lastMovements.Data.Count;
            lastMovements.addNext(Tuple.Create(currentPatrollersState.p1Dir * p1Moves,
                                               currentPatrollersState.p2Dir * p1Moves));
            p1AvgVel += lastMovements.Newest.Item1 / lastMovements.Data.Count;
            p2AvgVel += lastMovements.Newest.Item2 / lastMovements.Data.Count;
        }
        public int getExceedingDistance()
        {
            Point p1 = gameCircumference.advancePointOnCircumference(gameCircumference.TopLeft, currentPatrollersState.p1);
            Point p2 = gameCircumference.advancePointOnCircumference(gameCircumference.TopLeft, currentPatrollersState.p2);
            int P1toP2dist = gameCircumference.CWDistanceOnSquare(p1, p2);
            return P1toP2dist - targetCWDistance;
        }
        /// <summary>
        /// assumes patrollers are currently moving to the same direction
        /// </summary>
        public void startChangingDistance()
        {
            currentMovementState = MovementState.ChangingDistance;

            Point p1 = gameCircumference.advancePointOnCircumference(gameCircumference.TopLeft, currentPatrollersState.p1);
            Point p2 = gameCircumference.advancePointOnCircumference(gameCircumference.TopLeft, currentPatrollersState.p2);
            int P1toP2dist = (gameCircumference.CWDistanceOnSquare(p1, p2) + gameCircumference.PointCount) % gameCircumference.PointCount;


//#if DEBUG
//            currentPatrollersState.prevDistance = P1toP2dist;
//            currentPatrollersState.prevp1 = currentPatrollersState.p1;
//            currentPatrollersState.prevp2 = currentPatrollersState.p2;
//            currentPatrollersState.prevp1dir = currentPatrollersState.p1Dir;
//            currentPatrollersState.prevp2dor = currentPatrollersState.p2Dir;
//#endif

            do
            {
                
                targetCWDistance =
                    movementMethod.distances.CWDistancesPerProb[myRand.Next() % movementMethod.distances.CWDistancesPerProb.Count];

            }
            while (targetCWDistance == P1toP2dist); // we want a DIFFERENT distance (with probability preTransmissionMethod.c)


            if (targetCWDistance < P1toP2dist)
            {
                // make p1 go CC and p2 CCW
                if (currentPatrollersState.p1Dir == 1)
                    updatePatrollersPositions(1, 0, currentPatrollersState.p1Dir, -1); // rotate p2
                else
                    updatePatrollersPositions(0, 1, 1, currentPatrollersState.p2Dir); // rotate p1

            }
            else// if (currentPatrollersState.targetCWDistance > P1toP2dist)
            {
                // make p1 go CCW and p2 CC
                if (currentPatrollersState.p1Dir == -1)
                    updatePatrollersPositions(1, 0, currentPatrollersState.p1Dir, 1); // rotate p2
                else
                    updatePatrollersPositions(0, 1, -1, currentPatrollersState.p2Dir); // rotate p1

            }
        }

        /// <summary>
        /// updates currentPatrollersState according to given arguments.
        /// If movement can't be completed due to overspeeding, patroller will stay in place
        /// </summary>
        /// <param name="p1Moves">
        /// 0 if p1 is standing in place instead of advancing towards p1Dir (e.g. due to rotation), 1 otherwise
        /// </param>
        /// <param name="p2Moves">
        /// similar to p2Stands
        /// </param>
        private void updatePatrollersPositions(int p1Moves, int p2Moves, int newP1Dir, int newP2Dir)
        {
            // check if p1/p2 is still supposed to go to the overspeeding direction. If so, paralyze it
            if (Math.Abs(p1AvgVel) > movementMethod.distancesMgr.maxVelocity && p1Moves * newP1Dir * p1AvgVel > 0)
                p1Moves = 0;
            if (Math.Abs(p2AvgVel) > movementMethod.distancesMgr.maxVelocity && p2Moves * newP2Dir * p2AvgVel > 0)
                p2Moves = 0;

            currentPatrollersState.updatePatrollersPositions(p1Moves, p2Moves, newP1Dir, newP2Dir, gameCircumference.PointCount);

            updateAvgVel(p1Moves, p2Moves);
        }

        public override PatrollersState getCurrentState(PatrollersState s)
        {
            s.tag = targetCWDistance;
            return s;
        }
    }
    class RotatingBoundProcess : ABasicPatrollerHeuristicPolicyProcess
    {
        private class ProcessState
        {
            public ProcessState() { }
            public ProcessState(ProcessState src)
            {
                seq = new ConstrainedRandomSequence(src.seq);
                advanceBoundNextRound = src.advanceBoundNextRound;
                p1Bound = src.p1Bound;
                p2Bound = src.p2Bound;
                p1Dest = src.p1Dest;
                p2Dest = src.p2Dest;
            }
            public ConstrainedRandomSequence seq;
            public int advanceBoundNextRound;
            public int p1Bound, p2Bound;
            public int p1Dest, p2Dest;
        }

        ProcessState ps = new ProcessState();
        Grid4Square gameCircumference;
        IntrusionGameParams gamePrm;
        RotatingPatrollerBoundPreTransmissionMovement movementMethod;
        Random myRand;
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="updatedBound">
        /// bound of next round
        /// </param>
        /// <param name="currentLocation"></param>
        /// <param name="dir"></param>
        /// <param name="dest"></param>
        /// <param name="isSameDir"></param>
        private void updateDest(int updatedBound, int currentLocation, ref int dir, ref int dest, ref int isSameDir)
        {
            updatedBound %= gameCircumference.PointCount;

            // if either patroller reached destination, or it has to choose new destination in order to avoid getting out of range, update direction and destination
            if ((currentLocation == dest) || 
                (ps.advanceBoundNextRound == 1 && dir == -1 &&
                  gameCircumference.CWDistanceOnSquare(currentLocation, updatedBound) >= (movementMethod.Db - 1) ) )
            {
                
                // try to randomly advance cw:
                dest = (currentLocation + 1 + myRand.Next() % (2 * movementMethod.Db)) % gameCircumference.PointCount;

                int newDir = 1;
                // if dest "overflowed" the bound sector,  we reverse it to legal values, and patroller will advance CCW:
                int cw = gameCircumference.CWDistanceOnSquare(updatedBound, dest);
                int ccw = gameCircumference.CWDistanceOnSquare(dest, updatedBound); // makes sure new dest is not between currentLocation and bound
                if (ccw > movementMethod.Db && cw > movementMethod.Db)
                {
                    dest = (gameCircumference.PointCount + dest - (2 * movementMethod.Db + 1)) % gameCircumference.PointCount;
                    newDir = -1;
                }

                isSameDir = Convert.ToInt32(dir == newDir);
                dir = newDir;

            }
        }


        /// <summary>
        /// Tells when bounds should advance.
        /// 
        
        /// </summary>
        /// <param name="PbFactor"></param>
        /// <returns></returns>
        public ConstrainedRandomSequence getSB(float PbFactor)
        {
            
            int d = movementMethod.BoundAdvancingLimitationDenominator(gamePrm);
            int n = movementMethod.BoundAdvancingLimitationNumerator(gamePrm);
            return new ConstrainedRandomSequence(n,d);
            
        }
        

        public override PatrollersState getInitialState()
        {
            ps.p1Bound = myRand.Next() % gameCircumference.PointCount;
            ps.p2Bound = (ps.p1Bound + gameCircumference.PointCount / 2) % gameCircumference.PointCount;
            ps.seq = getSB(movementMethod.PbFactor);
            ps.advanceBoundNextRound = Convert.ToInt32(ps.seq.checkOccourance());//Convert.ToInt32(myRand.NextDouble() < movementMethod.Pb);
            PatrollersState res = new PatrollersState();
            res.p1 = (ps.p1Bound - movementMethod.Db) + myRand.Next() % (2 * movementMethod.Db + 1);
            res.p2 = (ps.p2Bound - movementMethod.Db) + myRand.Next() % (2 * movementMethod.Db + 1);

            int tmp = 0;
            res.p1Dir = 0;
            res.p2Dir = 0;
            ps.p1Dest = res.p1; // this will make updateDest replace the dest
            ps.p2Dest = res.p2; // this will make updateDest replace the dest
            updateDest(ps.p1Bound + ps.advanceBoundNextRound, res.p1, ref res.p1Dir, ref ps.p1Dest, ref tmp);
            updateDest(ps.p2Bound + ps.advanceBoundNextRound, res.p2, ref res.p2Dir, ref ps.p2Dest, ref tmp);
            
            return res;
        }

        public override PatrollersState getNextPatrollersState(PatrollersState currentPatrollersState)
        {
            PatrollersState res = new PatrollersState()
            {
                p1 = currentPatrollersState.p1,
                p2 = currentPatrollersState.p2,
                p1Dir = currentPatrollersState.p1Dir,
                p2Dir = currentPatrollersState.p2Dir
            };

            int p1Moves = 1, p2Moves = 1;

            if(ps.advanceBoundNextRound == 1)
            {
                ps.p1Bound = (ps.p1Bound + 1) % gameCircumference.PointCount;
                ps.p2Bound = (ps.p2Bound + 1) % gameCircumference.PointCount;

                if (ps.p1Dest != res.p1) // if patroller just reached in prev round to its destination, make sure it won't continue moving in the wrong direction
                {
                    if (gameCircumference.CWDistanceOnSquare(ps.p1Bound, ps.p1Dest) != movementMethod.Db) // make sure dest wasn't updated in prev round to the edge of the updated bound
                        ps.p1Dest = (ps.p1Dest + 1) % gameCircumference.PointCount;
                }

                if (ps.p2Dest != res.p2)
                {
                    if (gameCircumference.CWDistanceOnSquare(ps.p2Bound, ps.p2Dest) != movementMethod.Db) // make sure dest wasn't updated in prev round to the edge of the updated bound
                            ps.p2Dest = (ps.p2Dest + 1) % gameCircumference.PointCount;
                }

            }


            //if (ps.remainingCredits > 0)
            //{
            //    var randVal = Convert.ToInt32(myRand.NextDouble() < movementMethod.Pb);
            //    ps.advanceBoundNextRound = randVal;
            //    ps.remainingCredits = Math.Max(0, ps.remainingCredits - ps.advanceBoundNextRound); // if we move bound, we lose a credit
            //}
            ps.seq.advance();
            ps.advanceBoundNextRound = Convert.ToInt32(ps.seq.checkOccourance());

            //if (ps.advanceBoundNextRound == 0)
              //  ps.remainingCredits = Math.Min(MaxCredits, ps.remainingCredits + 1); // if we don't move bound, we earn credit

            updateDest(ps.p1Bound + ps.advanceBoundNextRound, res.p1, ref res.p1Dir, ref ps.p1Dest, ref p1Moves);
            updateDest(ps.p2Bound + ps.advanceBoundNextRound, res.p2, ref res.p2Dir, ref ps.p2Dest, ref p2Moves);

            res.updatePatrollersPositions(p1Moves, p2Moves, res.p1Dir, res.p2Dir, gameCircumference.PointCount);
            return res;
        }

        public override void setInitialState(PatrollersState initState)
        {
            //int tmp = 0;
            ps = new ProcessState((ProcessState)initState.tag);
            //updateDest(ps.p1Bound + ps.advanceBoundNextRound, initState.p1, ref initState.p1Dir, ref ps.p1Dest, ref tmp);
            //updateDest(ps.p2Bound + ps.advanceBoundNextRound, initState.p2, ref initState.p2Dir, ref ps.p2Dest, ref tmp);
            
        }

        protected override void init(PreTransmissionMovement prm, IntrusionGameParams GamePrm, Grid4Square GameCircumference)
        {
            myRand = new ThreadSafeRandom().rand;
            gameCircumference = GameCircumference;
            gamePrm=GamePrm;
            movementMethod = (RotatingPatrollerBoundPreTransmissionMovement)prm;
        }

        public override PatrollersState getCurrentState(PatrollersState cs)
        {
            cs.tag = ps;
            return cs;
        }
    }
    /// <summary>
    /// strategy with two patrollers faces the intruder described in class SingleTransmissionPerimOnlyIntruderPolicy
    /// 
    /// The preprocess stage generates a table that maps observed observations
    /// FIXME: I forgot what this policy even does
    /// </summary>
    class BasicPatrollerPolicy : AIntrusionPursuersPolicy
    {
        enum MovementState : int
        {
            //GoingForward = 0,
            //ChangingDistance = 1,
            PreTransmission = 0,
            PostTransmission = 1
        }

        ABasicPatrollerHeuristicPolicyProcess preTransmissionProcess;

        Grid4Square gameCircumference;
        IntrusionGameParams prm;
        Dictionary<string, string> policyParams;
        //DistanceKeepingMethod distMethod;
        PostTransmissionMovement postTransmissionMethod;
        //PreTransmissionMovement preTransmissionMethod;

        Random myRand;
        MovementState currentMovementState;
        PatrollersState currentPatrollersState;
        int roundsSinceTransmission = -1;
        Dictionary<Pursuer, List<Point>> patrollerLocations = new Dictionary<Pursuer, List<Point>>();

        public override List<ArgEntry> policyInputKeys()
        {
            //get
            //{
                var res = new List<ArgEntry>();
                
                return res;
            //}
        }
        public PatrollersState PatrollersState
        {
            get
            {
                return preTransmissionProcess.getCurrentState(currentPatrollersState);
            }
        }

        public override APolicyOptimizer constructTheoreticalOptimizer()
        {
            return new SingleTransmissionPerimOnlyHeuristicOptimizer();
        }
        public override bool init(AGameGraph G, 
                                  IntrusionGameParams Prm, 
                                  IPolicyGUIInputProvider pgui, Dictionary<string, string> PolicyParams)
        {
            myRand = new ThreadSafeRandom().rand;
            this.prm = Prm;
            policyParams = PolicyParams;
            gameCircumference = prm.SensitiveAreaSquare(((GridGameGraph)G).getNodesByType(NodeType.Target)[0]);

#if DEBUG // used for GUI, if no initOpt() is called

            preTransmissionProcess = ABasicPatrollerHeuristicPolicyProcess.Construct(
                new RotatingPatrollerBoundPreTransmissionMovement(0.3f, 1), prm, gameCircumference);

            //var distances = DistanceKeepingMethod.generateMovements(9, gameCircumference.PointCount).First(); 
            //var allMgrs = DistanceKeepingMethodManager.generateMovements(121);
            //var distancesMgr = allMgrs[allMgrs.Count - 10 + myRand.Next() % 10];

            postTransmissionMethod =
                PostTransmissionMovement.generateMovementes(9, gameCircumference.PointCount, 2).First().Value.First();

            //DistanceDistributionPreTransmissionMovement movementPrm =
            //    new DistanceDistributionPreTransmissionMovement(distances, distancesMgr);
            //preTransmissionProcess = APatrollerPolicyProcess.Construct(movementPrm,prm,gameCircumference); // in case initOpt isn't called - randomize everything
            currentPatrollersState = preTransmissionProcess.getInitialState();
#endif

            return true;
        }

        // fixme: normal init() should be used instead, with serialized version of the structs
        public void initOpt(PreTransmissionMovement preMove,
                            PostTransmissionMovement PostTransmissionMethod,
                            PatrollersState? InitialState = null)
        {
            //this.gameCircumference = GameCircumference;
            preTransmissionProcess = ABasicPatrollerHeuristicPolicyProcess.Construct(preMove, prm, gameCircumference);
            postTransmissionMethod = PostTransmissionMethod;
            
            if (InitialState != null)
            {
                currentPatrollersState = InitialState.Value;
                preTransmissionProcess.setInitialState(currentPatrollersState);
            }
            else
            {
                //currentPatrollersState.p1 = myRand.Next() % gameCircumference.PointCount;
                //currentPatrollersState.p2 = (currentPatrollersState.p1 +
                //    distMethod.CWDistancesPerProb[myRand.Next() % distMethod.CWDistancesPerProb.Count]) % gameCircumference.PointCount;

                //currentMovementState = MovementState.GoingForward;
                //currentPatrollersState.p1Dir = currentPatrollersState.p2Dir = chooseForwardDistance();
                currentPatrollersState = preTransmissionProcess.getInitialState();
            }

            //var initialVals = AlgorithmUtils.getRepeatingValueList((int)Math.Ceiling(1.0 / preTransmissionMethod.maxVelocity), 
            //                                                       () => { return Tuple.Create(0, 0); });
            //lastMovements = new CyclicList<Tuple<int,int>>(initialVals);
        }
        
        
        public override void setGameState(int currentRound, List<Point> O_c, IEnumerable<GameLogic.Utils.CapturedObservation> O_d)
        {
            if (O_c.Count > 0)
            {
                currentMovementState = MovementState.PostTransmission;
                roundsSinceTransmission = 0;
            }
            else
                ++roundsSinceTransmission;
        }

  
        public override Dictionary<Pursuer, List<Point>> getNextStep()
        {
           
            switch(currentMovementState)
            {
                case MovementState.PreTransmission:
                    currentPatrollersState = preTransmissionProcess.getNextPatrollersState(currentPatrollersState);
                    break;
                case MovementState.PostTransmission:
                    // if we reached the switch round, then switch direction. otherwise, continue
                    if ((postTransmissionMethod.LastReadIdx + 1) == postTransmissionMethod.RoundsToRotate.Count)
                    {
                        // if patrollers won't rotate anymore:
                        currentPatrollersState.updatePatrollersPositions(1, 1, currentPatrollersState.p1Dir, currentPatrollersState.p2Dir, gameCircumference.PointCount);
                    }
                    else if (roundsSinceTransmission >= postTransmissionMethod.RoundsToRotate[postTransmissionMethod.LastReadIdx + 1])
                    {
                        ++postTransmissionMethod.LastReadIdx;
                        currentPatrollersState.updatePatrollersPositions(0, 0, -currentPatrollersState.p1Dir, -currentPatrollersState.p2Dir, gameCircumference.PointCount); // switch direction
                    }
                    else
                        currentPatrollersState.updatePatrollersPositions(1, 1, currentPatrollersState.p1Dir, currentPatrollersState.p2Dir, gameCircumference.PointCount); // continue as usual, until next rotation

                    break;

            }
            
            patrollerLocations[prm.A_P[0]] = AlgorithmUtils.getRepeatingValueList(
                gameCircumference.advancePointOnCircumference(gameCircumference.TopLeft, currentPatrollersState.p1),1);
            patrollerLocations[prm.A_P[1]] = AlgorithmUtils.getRepeatingValueList(
                gameCircumference.advancePointOnCircumference(gameCircumference.TopLeft, currentPatrollersState.p2),1);

            return patrollerLocations;
        }

        
    }


}